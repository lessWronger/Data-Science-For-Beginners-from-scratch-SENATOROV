"""Numpy."""

# +
# Массив Numpy — это многомерный
# массив (ndarray, n-dimensional array) данных,
# над которыми можно быстро и эффективно выполнять
# множество математических, статистических,
# логических и других операций.

# импортируем библиотеку matplotlib
# import matplotlib.pyplot as plt
# import numpy as np

# импортируем функцию csr_matrix()
# from scipy.sparse import csr_matrix

# создадим массив из списка
# arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# arr

# +
# или кортежа
# arr = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
# arr

# +
# создадим список с помощью функций range() и list()
# list(range(2, 5.5, 0.5))

# +
# np.arange(2, 5.5, 0.5)

# +
# создадим массив с элементами типа float
# arr_f = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], float)

# print(arr_f)

# тип данных можно посмотреть через атрибут dtype
# print(arr_f.dtype)

# +
# arr.ndim

# +
# arr.shape

# +
# пока что у нас одно измерение, в котором четыре элемента
# arr.size

# +
# в нашем случае - это целое число длиной 64 бита
# arr.dtype

# +
# arr.itemsize

# +
# # у нас четыре элемента по восемь байтов или 32 байта
# arr.nbytes

# +
# Массив с нулевой размерностью — это число (скаляр) и квадратных скобок не имеет.

# arr_0D = np.array(42)
# arr_0D

# +
# print(arr_0D.ndim)
# print(arr_0D.shape)
# print(arr_0D.size)

# +
# Одномерный массив (вектор)
# arr_1D = np.array([1, 2, 3])
# arr_1D

# +
# print(arr_1D.ndim)
# print(arr_1D.shape)
# print(arr_1D.size)

# +
# Двумерный массив (матрица)
# с точки зрения синтаксиса - это просто вложенные списки
# arr_2D = np.array([[1, 2, 3], [4, 5, 6]])
# arr_2D

# +
# print(arr_2D.ndim)
# print(arr_2D.shape)
# print(arr_2D.size)

# +
# column = np.array([[1], [2], [3]])
# column

# +
# посмотрим на размерность
# column.shape

# +
# row = np.array([[1, 2, 3]])
# row

# +
# размерность будет иной
# row.shape

# +
# Трехмерный массив
# arr_3D = np.arange(12).reshape(2, 2, 3)
# arr_3D

# +
# print(arr_3D.ndim)
# print(arr_3D.shape)
# print(arr_3D.size)

# +
# Массив из нулей
# ей мы можем передать одно значение для создания одномерного массива
# np.zeros(5)

# +
# или кортеж из чисел для указания количества нулей в каждом измерении
# np.zeros((2, 3))

# +
# Массив из единиц
# создадим трехмерный массив
# np.ones((2, 2, 3))

# +
# Массив, заполненный заданным значением
# np.full((2, 3), 4)

# +
# Пустой массив Numpy
# создадим пустую матрицу 3 х 2
# np.empty((3, 2))

# +
# любой массив Numpy можно преобразовать
# в описанные выше массивы с помощью функций
# np.zeros_like(), np.ones_like(),
# np.full_like() и np.empty_like().
# Приведу пример для np.zeros_like().
# создадим массив 2 x 3 с числами от 1 до 6
# arr1 = np.arange(1, 7).reshape(2, 3)
# arr1

# +
# и превратим его в массив с нулями
# np.zeros_like(arr1)

# +
# Функция np.linspace()
# создадим диапазон от 0 до 0,9 и
# разделим его на десять точек, включая 0 и 0,9
# np.linspace(0, 0.9, 10)

# +
# с функцией np.arange мы точно знаем, где будут расположены точки
# np.arange(0, 1, 0.1)

# +
# зададим размер графика в дюймах
# plt.figure(figsize=(8, 6))

# зададим интервал, например, от -5 до 5 и сформируем на нем 5000 точек
# это будут наши координаты по оси x
# x = np.linspace(-5, 5, 5000)

# по оси y отложим квадрат этих точек
# y = x**2

# создадим сетку
# plt.grid()

# выведем кривую и подписи на графике
# plt.plot(x, y)
# plt.xlabel("x", fontsize=14)
# plt.ylabel("y", fontsize=14)

# результатом будет парабола
# plt.show()

# +
# Функции np.random.rand() и np.random.randint()
# np.random.rand(4, 3)

# +
# создадим массив размерностью 2 x 3 x 2 c числами [-3, 3)
# np.random.randint(-3, 3, size=(2, 3, 2))

# +
# Функция np.fromfunction()
# берет координаты (i, j) каждой ячейки
# и передает их в собственную функцию.
# создадим собственную функцию,
# которая принимает два числа
# и возводит первое число в степень второго


# def power(i, j) -> int:
#     return i**j

# +
# np.fromfunction(power, (3, 3))

# +
# Матрица csr и метод .toarray()
# создадим матрицу с преобладанием нулевых значений
# A = np.array([[2, 0, 0, 1, 0, 0, 0],
# [0, 0, 3, 0, 0, 2, 0], [0, 0, 0, 1, 0, 0, 0]])
# A

# +
# 1.0 - np.count_nonzero(A) / A.size

# +
# и применим ее к матрице А
# B = csr_matrix(A)
# print(B)

# +
# C = B.toarray()
# C

# +
# Индекс элемента массива
# a = np.array([[1, 2, 3], [4, 5, 6]])
# a

# +
# первый элемент представляет собой вектор
# a[0]

# +
# a[0][0], a[1][2]

# +
# Срез массива
# b = np.array([1, 2, 3, 4, 5, 6, 7, 8])
# b

# +
# b[1:6:2]

# +
# c = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
# c

# +
# 0 указывает на первую строку, диапазон :2 - на первые два столбца
# c[0, :2]

# +
# c[:, 1]

# +
# # выведем элемент в первой строке и первом столбце
# c[0, 0]

# +
# # выведем элемент в последней строке и последнем столбце
# c[-1, -1]

# +
# c[1, ::2]

# +
# d = np.arange(16).reshape(4, 2, -1)
# d

# +
# d[2][1][0]

# +
# # выведем третью и четвертую матрицу [2:]
# # и в них вторую строку [1] и все столбцы [:]
# d[2:, 1, :]

# +
# # Оси массива

# arr_2D = np.array([[1, 2], [3, 4]])
# arr_2D

# +
# np.sum(arr_2D, axis=0)

# +
# np.sum(arr_2D, axis=1)

# +
# np.sum(arr_2D, axis=(0, 1)), np.sum(arr_2D)

# +
# # Отрицательные значения в параметре axis
# np.sum(arr_2D, axis=-1), np.sum(arr_2D, axis=-2)

# +
# # Массив 3D
# np.sum(arr_3D, axis=0)

# +
# # возьмем первую матрицу
# arr_3D[0]

# +
# # возьмем вторую матрицу
# arr_3D[1]

# +
# # и поэлементно сложим их
# arr_3D[0] + arr_3D[1]

# +
# total = np.zeros((2, 3))

# +
# for i in range(2):
#     total += i
# total

# +
# # Сложение вдоль второй оси (axis = 1)
# np.sum(arr_3D, axis=1)

# +
# # сложим столбцы первой
# arr_3D[0][0] + arr_3D[0][1]

# +
# # и второй матрицы
# arr_3D[1][0] + arr_3D[1][1]

# +
# total1 = np.zeros((2, 3))
# for i in range(2):
#     for j in range(2):
#         total1[i] += arr_3D[i][j]

# +
# # Сложение вдоль третьей оси (axis = 2)
# # применим np.sum()
# np.sum(arr_3D, axis=2)

# +
# arr_3D[0][0][0] + arr_3D[0][0][1] + arr_3D[0][0][2]

# +
# # создадим нулевой массив 2 x 2 для записи результатов
# total = np.zeros((2, 2))

# # пройдемся по матрицам
# for i in range(2):

#     # по строкам матрицы
#     for j in range(2):

#         # и по столбцам
#         for k in arr_3D[i][j]:

#             # индексы i, j запишут результат сложения элементов строк k
#             # в квадратную матрицу 2 x 2
#             total[i][j] += k

# total

# +
# # Сложение вдоль первой и второй осей (axis = (0, 1))
# # применим функцию np.sum()
# np.sum(arr_3D, axis=(0, 1))

# +
# # произведем сложение по оси 0
# total_0 = np.zeros((2, 3))

# for i in range(2):
#     total_0 += arr_3D[i]

# total_0

# +
# # произведем сложение по оси 1
# total_1 = np.zeros(3)

# for j in range(2):
#     total_1 += total_0[j]

# total_1

# +
# total = np.zeros(3)

# for i in range(2):
#     for j in range(2):
#         total += arr_3D[i][j]

# total

# +
# # Сложение вдоль всех трех осей (axis = (0, 1, 2))
# np.sum(arr_3D, axis=(0, 1, 2))

# +
# total = 0
# # в трех вложенных циклах мы пройдемся по всем элементам массива
# for i in range(2):
#     for j in range(2):
#         for k in range(3):

#             # и запишем сумму этих элементов в переменную total
#             total += arr_3D[i][j][k]

# total

# +
# # Операции с массивами
# arr_3D = np.arange(12).reshape(2, 2, 3)
# len(arr_3D), len(arr_3D[0][0])

# +
# # Распаковка массива
# a = np.arange(1, 28).reshape(3, 9)
# x, y, z = a
# x, *y, z = a[0]

# +
# print(x)
# print(y)
# print(z)

# +
# # Изменение элементов массива

# arr_2D = np.array([[1, 2, 3], [4, 5, 6]])
# arr_2D[0, 0] = 2
# arr_2D

# +
# # Запишем значение 1 в первую строку.
# arr_2D[0] = 1
# arr_2D

# +
# # Пусть третий столбец массива состоит из нулей.
# arr_2D[:, 2] = 0
# arr_2D

# +
# # Теперь потренируемся с трехмерным массивом.
# arr_3D = np.arange(12).reshape(2, 2, 3)
# # Выберем второй столбец второй матрицы и заменим значения столбца 7 и 10 на 0 и 1.
# # при такой операции размер среза должен совпадать
# # с количеством передаваемых значений
# arr_3D[1, :, 1] = [0, 1]
# arr_3D

# +
# arr_3D.fill(7)
# arr_3D

# +
# # Сортировка массива и обратный порядок его элементов
# a = np.array([[4, 8, 2], [2, 3, 1]])
# np.sort(a)

# +
# np.sort(a, axis=1)

# +
# np.sort(a, axis=0)

# +
# np.sort(a, axis=None)

# +
# # Обратный порядок элементов массива
# np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[::-1]

# +
# # обратите внимание, мы используем и положительный, и отрицательный индексы
# np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])[-3:3:-1]

# +
# # Сортировка в убывающем порядке

# # возьмем простой одномерный массив
# a = np.array([4, 2, 6, 1, 7, 3, 5])

# np.sort(a)[::-1]

# +
# # здесь нужно сначала задать обратный порядок, а потом отсортировать
# a[::-1].sort()

# +
# # Изменение размерности
# arr_3D = np.arange(12).reshape(2, 2, 3)
# arr_3D

# +
# # в нем 12 элементов
# arr_3D.size

# +
# # при этом важно, чтобы общее количество элементов было тем же
# arr_2D = arr_3D.reshape(2, 6)
# arr_2D

# +
# # Функция np.resize() и метод .resize()
# # функция np.resize() позволяет не сохранять прежнее количество элементов
# # существующие элементы копируются в новые ячейки
# np.resize(arr_2D, (3, 6))

# +
# arr_2D_copy = arr_2D.copy()

# +
# # Методы .flatten() и .ravel()
# arr_3D.flatten()

# +
# arr_3D.ravel()

# +
# # np.newaxis

# # создадим одномерный массив
# a = np.array([1, 2, 3])
# a.shape

# +
# b = a[np.newaxis, :]

# print(b)
# print(b.shape)

# +
# # Функция np.concatenate()
# a = np.arange(4).reshape(2, 2)
# b = np.arange(4, 8).reshape(2, 2)

# +
# np.concatenate((a, b), axis=0)

# +
# # Функция np.stack()
# # при axis = 0 мы просто добавляем внешнее измерение
# np.stack((a, b), axis=0)
